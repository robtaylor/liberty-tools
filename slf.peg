liberty <- library* EOF;

// By convention: K_xxx is keyword xxx
library <- K_LIBRARY LPAREN libraryname RPAREN
                LCURLY libraryele* RCURLY;

libraryname <- IDENT / STRING;

// cell must be first to match 'cell' keyword
libraryele <- cell / keyvalue;

cell <- K_CELL LPAREN (IDENT / STRING) RPAREN valueset;

valueset <- LCURLY keyvalue* RCURLY;

keyvalue <- IDENT COLON valuetype SEMI?
         /  IDENT LPAREN valuetypelist? RPAREN
                ( valueset /  SEMI? );

valuetype <- expr
          /  vident bus?
          /  STRING
          /  number (unit !(COLON / LPAREN))?
          /  bool;

bus <- LBRACK number (COLON number)? RBRACK;

unit <- IDENT;

valuetypelist <- valuetype (COMMA valuetype)*;

bool <- K_TRUE / K_FALSE;

expr <- exprval (exprop exprval)+;

exprval <- IDENT / number;

exprop <- STAR / PLUS;

number <- (float / integer);

// NOTE: order of alts important since CELL matches an IDENT
vident <- K_CELL / K_LIBRARY / IDENT;

// lexical syntax

COLON       <- ':';
COMMA       <- ',';
LCURLY      <- '{';
RCURLY      <- '}';
LPAREN      <- '(';
RPAREN      <- ')';
LBRACK      <- '[';
RBRACK      <- ']';
SEMI        <- ';';
STAR        <- '*';
PLUS        <- '+';
K_CELL      <- "cell";
K_LIBRARY   <- "library";
K_TRUE      <- "true";
K_FALSE     <- "false";

IDENT      <- identstart identcont*;
identstart <- r'[a-zA-Z_]';
identcont  <- identstart / r'[0-9.+/]' / '-';

integer <- r'[-+]'? digit+;

digit <- r'[0-9]';

float <- integer ('.' digit+)? (r'[eE]' integer)?;

// include \\. EOLN so string can span lines
STRING <- ".*?";

comment <- SL_COMMENT / ML_COMMENT;

SL_COMMENT  <- r'"//.*"';

ML_COMMENT <- r'"/\*.*\*/"';

